#!/usr/bin/env python
import sys
import time
from subprocess import *
import psutil
import matplotlib.pyplot as plt

# -f file.txt : output information to a file rather than stderr
# -d          : debug mode, prints the logs in prompt
# -t          : time, prints the exectuion time

out = sys.stderr
FILE = False
DEBUG = False
TIMER = False

vss_peak = -1
rss_peak = -1
exec_count = 0

child_args = []
i = 1
while i < len(sys.argv):
    if sys.argv[i] == '-f':
        i += 1
        out = open(sys.argv[i], 'w')
        FILE = True
    elif sys.argv[i] == '-t':
        TIMER = True
    elif sys.argv[i] == '-d':
        DEBUG = True
    else:
        child_args.append(sys.argv[i])
    i += 1

def log(msg):
    if DEBUG:
        print("memTool: {}".format(msg))
    if FILE:
        out.write("memTool: {} \n".format(msg))

log(child_args)

def measure_memory(pid):
    process = psutil.Process(pid)
    mem_info = process.memory_info()
    log("\n\n ####### Process infos #######")
    log("Process pid is : {}".format(pid))
    log("Process mem is : {}".format(mem_info))
    log("Process command line is : {}".format(process.cmdline()))
    vss = mem_info.vms
    rss = mem_info.rss

    log("\n\n ####### Child infos #######")
    forks = process.children(recursive=True)
    for fork in forks:
            assert fork.pid != fork.ppid()
            fork_mem_info = fork.memory_info()
            log("Child pid is {}".format(fork.pid))
            log("Child mem is {}".format(fork_mem_info))
            log("Child command line is : {}".format(fork.cmdline()))
            vss += fork_mem_info.vms
            rss += fork_mem_info.rss

    return vss, rss

log("Starting child: {}".format(child_args))
proc = psutil.Popen(child_args, stdin=None, stdout=None, stderr=None, env=None, shell=True)

if TIMER: 
    start_time = proc.create_time()

while proc.returncode == None:
    current_vss, current_rss = measure_memory(proc.pid)
    vss_peak = max(current_vss, vss_peak)
    rss_peak = max(current_rss, rss_peak)
    log("Waiting for child to exit. VSS Peak={} RSS Peak={} ".format(vss_peak,rss_peak))
    exec_count += 1
    proc.poll()     # Check if child process has finished
    
out.write("memTool: VSS Peak: {:.1f} Mo\n".format(vss_peak / 1000000))
out.write("memTool: RSS Peak: {:.1f} Mo\n".format(rss_peak / 1000000))
out.write("memTool: Number of samples : {} \n".format(exec_count))
if TIMER:
    out.write("memTool: Execution time: {:.1f} s\n".format(time.time() - start_time))

status = proc.returncode
log("Child process returned {}".format(status))

sys.exit(status)
